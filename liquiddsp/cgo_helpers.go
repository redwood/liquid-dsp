// THE AUTOGENERATED LICENSE. ALL THE RIGHTS ARE RESERVED BY ROBOTS.

// WARNING: This file has automatically been generated on Wed, 24 Nov 2021 17:31:22 CST.
// Code generated by https://git.io/c-for-go. DO NOT EDIT.

package liquiddsp

/*
#cgo CFLAGS: -msse4.1 -Wall -fPIC -I. -I.. -I../include
#cgo LDFLAGS: -lm ${SRCDIR}/../libliquid.a
#include <inttypes.h>
#include <complex.h>
#include "liquid.h"
#include "liquid.internal.h"
#include <stdlib.h>
#include "cgo_helpers.h"
*/
// import "C"
// import (
// 	"fmt"
// 	"runtime"
// 	"sync"
// 	"unsafe"
// )

// // cgoAllocMap stores pointers to C allocated memory for future reference.
// type cgoAllocMap struct {
// 	mux sync.RWMutex
// 	m   map[unsafe.Pointer]struct{}
// }

// var cgoAllocsUnknown = new(cgoAllocMap)

// func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
// 	a.mux.Lock()
// 	if a.m == nil {
// 		a.m = make(map[unsafe.Pointer]struct{})
// 	}
// 	a.m[ptr] = struct{}{}
// 	a.mux.Unlock()
// }

// func (a *cgoAllocMap) IsEmpty() bool {
// 	a.mux.RLock()
// 	isEmpty := len(a.m) == 0
// 	a.mux.RUnlock()
// 	return isEmpty
// }

// func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
// 	if b == nil || b.IsEmpty() {
// 		return
// 	}
// 	b.mux.Lock()
// 	a.mux.Lock()
// 	for ptr := range b.m {
// 		if a.m == nil {
// 			a.m = make(map[unsafe.Pointer]struct{})
// 		}
// 		a.m[ptr] = struct{}{}
// 		delete(b.m, ptr)
// 	}
// 	a.mux.Unlock()
// 	b.mux.Unlock()
// }

// func (a *cgoAllocMap) Free() {
// 	a.mux.Lock()
// 	for ptr := range a.m {
// 		C.free(ptr)
// 		delete(a.m, ptr)
// 	}
// 	a.mux.Unlock()
// }

// // allocFrameSyncStatsMemory allocates memory for type C.framesyncstats_s in C.
// // The caller is responsible for freeing the this memory via C.free.
// func allocFrameSyncStatsMemory(n int) unsafe.Pointer {
// 	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFrameSyncStatsValue))
// 	if mem == nil {
// 		panic(fmt.Sprintln("memory alloc error: ", err))
// 	}
// 	return mem
// }

// const sizeOfFrameSyncStatsValue = unsafe.Sizeof([1]C.framesyncstats_s{})

// type sliceHeader struct {
// 	Data unsafe.Pointer
// 	Len  int
// 	Cap  int
// }

// // allocLiquidFloatComplexMemory allocates memory for type C.liquid_float_complex in C.
// // The caller is responsible for freeing the this memory via C.free.
// func allocLiquidFloatComplexMemory(n int) unsafe.Pointer {
// 	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfLiquidFloatComplexValue))
// 	if mem == nil {
// 		panic(fmt.Sprintln("memory alloc error: ", err))
// 	}
// 	return mem
// }

// const sizeOfLiquidFloatComplexValue = unsafe.Sizeof([1]C.liquid_float_complex{})

// const sizeOfPtr = unsafe.Sizeof(&struct{}{})

// // unpackSComplexfloat transforms a sliced Go data structure into plain C format.
// func unpackSComplexfloat(x []Complexfloat) (unpacked *C.liquid_float_complex, allocs *cgoAllocMap) {
// 	if x == nil {
// 		return nil, nil
// 	}
// 	allocs = new(cgoAllocMap)
// 	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
// 		go a.Free()
// 	})

// 	len0 := len(x)
// 	mem0 := allocLiquidFloatComplexMemory(len0)
// 	allocs.Add(mem0)
// 	h0 := &sliceHeader{
// 		Data: mem0,
// 		Cap:  len0,
// 		Len:  len0,
// 	}
// 	v0 := *(*[]C.liquid_float_complex)(unsafe.Pointer(h0))
// 	for i0 := range x {
// 		allocs0 := new(cgoAllocMap)
// 		v0[i0], allocs0 = x[i0].PassValue()
// 		allocs.Borrow(allocs0)
// 	}
// 	h := (*sliceHeader)(unsafe.Pointer(&v0))
// 	unpacked = (*C.liquid_float_complex)(h.Data)
// 	return
// }

// // packSComplexfloat reads sliced Go data structure out from plain C format.
// func packSComplexfloat(v []Complexfloat, ptr0 *C.liquid_float_complex) {
// 	const m = 0x7fffffff
// 	for i0 := range v {
// 		ptr1 := (*(*[m / sizeOfLiquidFloatComplexValue]C.liquid_float_complex)(unsafe.Pointer(ptr0)))[i0]
// 		v[i0] = Complexfloat(ptr1)
// 	}
// }

// // Ref returns the underlying reference to C object or nil if struct is nil.
// func (x *FrameSyncStats) Ref() *C.framesyncstats_s {
// 	if x == nil {
// 		return nil
// 	}
// 	return x.refc8b037e1
// }

// // Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// // Does nothing if struct is nil or has no allocation map.
// func (x *FrameSyncStats) Free() {
// 	if x != nil && x.allocsc8b037e1 != nil {
// 		x.allocsc8b037e1.(*cgoAllocMap).Free()
// 		x.refc8b037e1 = nil
// 	}
// }

// // NewFrameSyncStatsRef creates a new wrapper struct with underlying reference set to the original C object.
// // Returns nil if the provided pointer to C object is nil too.
// func NewFrameSyncStatsRef(ref unsafe.Pointer) *FrameSyncStats {
// 	if ref == nil {
// 		return nil
// 	}
// 	obj := new(FrameSyncStats)
// 	obj.refc8b037e1 = (*C.framesyncstats_s)(unsafe.Pointer(ref))
// 	return obj
// }

// // PassRef returns the underlying C object, otherwise it will allocate one and set its values
// // from this wrapping struct, counting allocations into an allocation map.
// func (x *FrameSyncStats) PassRef() (*C.framesyncstats_s, *cgoAllocMap) {
// 	if x == nil {
// 		return nil, nil
// 	} else if x.refc8b037e1 != nil {
// 		return x.refc8b037e1, nil
// 	}
// 	memc8b037e1 := allocFrameSyncStatsMemory(1)
// 	refc8b037e1 := (*C.framesyncstats_s)(memc8b037e1)
// 	allocsc8b037e1 := new(cgoAllocMap)
// 	allocsc8b037e1.Add(memc8b037e1)

// 	var cevm_allocs *cgoAllocMap
// 	refc8b037e1.evm, cevm_allocs = (C.float)(x.Evm), cgoAllocsUnknown
// 	allocsc8b037e1.Borrow(cevm_allocs)

// 	var crssi_allocs *cgoAllocMap
// 	refc8b037e1.rssi, crssi_allocs = (C.float)(x.Rssi), cgoAllocsUnknown
// 	allocsc8b037e1.Borrow(crssi_allocs)

// 	var ccfo_allocs *cgoAllocMap
// 	refc8b037e1.cfo, ccfo_allocs = (C.float)(x.Cfo), cgoAllocsUnknown
// 	allocsc8b037e1.Borrow(ccfo_allocs)

// 	var cframesyms_allocs *cgoAllocMap
// 	refc8b037e1.framesyms, cframesyms_allocs = unpackSComplexfloat(x.Framesyms)
// 	allocsc8b037e1.Borrow(cframesyms_allocs)

// 	var cnum_framesyms_allocs *cgoAllocMap
// 	refc8b037e1.num_framesyms, cnum_framesyms_allocs = (C.uint)(x.NumFramesyms), cgoAllocsUnknown
// 	allocsc8b037e1.Borrow(cnum_framesyms_allocs)

// 	var cmod_scheme_allocs *cgoAllocMap
// 	refc8b037e1.mod_scheme, cmod_scheme_allocs = (C.uint)(x.ModScheme), cgoAllocsUnknown
// 	allocsc8b037e1.Borrow(cmod_scheme_allocs)

// 	var cmod_bps_allocs *cgoAllocMap
// 	refc8b037e1.mod_bps, cmod_bps_allocs = (C.uint)(x.ModBps), cgoAllocsUnknown
// 	allocsc8b037e1.Borrow(cmod_bps_allocs)

// 	var ccheck_allocs *cgoAllocMap
// 	refc8b037e1.check, ccheck_allocs = (C.uint)(x.Check), cgoAllocsUnknown
// 	allocsc8b037e1.Borrow(ccheck_allocs)

// 	var cfec0_allocs *cgoAllocMap
// 	refc8b037e1.fec0, cfec0_allocs = (C.uint)(x.Fec0), cgoAllocsUnknown
// 	allocsc8b037e1.Borrow(cfec0_allocs)

// 	var cfec1_allocs *cgoAllocMap
// 	refc8b037e1.fec1, cfec1_allocs = (C.uint)(x.Fec1), cgoAllocsUnknown
// 	allocsc8b037e1.Borrow(cfec1_allocs)

// 	x.refc8b037e1 = refc8b037e1
// 	x.allocsc8b037e1 = allocsc8b037e1
// 	return refc8b037e1, allocsc8b037e1

// }

// // PassValue does the same as PassRef except that it will try to dereference the returned pointer.
// func (x FrameSyncStats) PassValue() (C.framesyncstats_s, *cgoAllocMap) {
// 	if x.refc8b037e1 != nil {
// 		return *x.refc8b037e1, nil
// 	}
// 	ref, allocs := x.PassRef()
// 	return *ref, allocs
// }

// // Deref uses the underlying reference to C object and fills the wrapping struct with values.
// // Do not forget to call this method whether you get a struct for C object and want to read its values.
// func (x *FrameSyncStats) Deref() {
// 	if x.refc8b037e1 == nil {
// 		return
// 	}
// 	x.Evm = (float32)(x.refc8b037e1.evm)
// 	x.Rssi = (float32)(x.refc8b037e1.rssi)
// 	x.Cfo = (float32)(x.refc8b037e1.cfo)
// 	packSComplexfloat(x.Framesyms, x.refc8b037e1.framesyms)
// 	x.NumFramesyms = (uint32)(x.refc8b037e1.num_framesyms)
// 	x.ModScheme = (uint32)(x.refc8b037e1.mod_scheme)
// 	x.ModBps = (uint32)(x.refc8b037e1.mod_bps)
// 	x.Check = (uint32)(x.refc8b037e1.check)
// 	x.Fec0 = (uint32)(x.refc8b037e1.fec0)
// 	x.Fec1 = (uint32)(x.refc8b037e1.fec1)
// }

// // allocFrameDataStatsMemory allocates memory for type C.framedatastats_s in C.
// // The caller is responsible for freeing the this memory via C.free.
// func allocFrameDataStatsMemory(n int) unsafe.Pointer {
// 	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFrameDataStatsValue))
// 	if mem == nil {
// 		panic(fmt.Sprintln("memory alloc error: ", err))
// 	}
// 	return mem
// }

// const sizeOfFrameDataStatsValue = unsafe.Sizeof([1]C.framedatastats_s{})

// // Ref returns the underlying reference to C object or nil if struct is nil.
// func (x *FrameDataStats) Ref() *C.framedatastats_s {
// 	if x == nil {
// 		return nil
// 	}
// 	return x.refcfe827
// }

// // Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// // Does nothing if struct is nil or has no allocation map.
// func (x *FrameDataStats) Free() {
// 	if x != nil && x.allocscfe827 != nil {
// 		x.allocscfe827.(*cgoAllocMap).Free()
// 		x.refcfe827 = nil
// 	}
// }

// // NewFrameDataStatsRef creates a new wrapper struct with underlying reference set to the original C object.
// // Returns nil if the provided pointer to C object is nil too.
// func NewFrameDataStatsRef(ref unsafe.Pointer) *FrameDataStats {
// 	if ref == nil {
// 		return nil
// 	}
// 	obj := new(FrameDataStats)
// 	obj.refcfe827 = (*C.framedatastats_s)(unsafe.Pointer(ref))
// 	return obj
// }

// // PassRef returns the underlying C object, otherwise it will allocate one and set its values
// // from this wrapping struct, counting allocations into an allocation map.
// func (x *FrameDataStats) PassRef() (*C.framedatastats_s, *cgoAllocMap) {
// 	if x == nil {
// 		return nil, nil
// 	} else if x.refcfe827 != nil {
// 		return x.refcfe827, nil
// 	}
// 	memcfe827 := allocFrameDataStatsMemory(1)
// 	refcfe827 := (*C.framedatastats_s)(memcfe827)
// 	allocscfe827 := new(cgoAllocMap)
// 	allocscfe827.Add(memcfe827)

// 	var cnum_frames_detected_allocs *cgoAllocMap
// 	refcfe827.num_frames_detected, cnum_frames_detected_allocs = (C.uint)(x.NumFramesDetected), cgoAllocsUnknown
// 	allocscfe827.Borrow(cnum_frames_detected_allocs)

// 	var cnum_headers_valid_allocs *cgoAllocMap
// 	refcfe827.num_headers_valid, cnum_headers_valid_allocs = (C.uint)(x.NumHeadersValid), cgoAllocsUnknown
// 	allocscfe827.Borrow(cnum_headers_valid_allocs)

// 	var cnum_payloads_valid_allocs *cgoAllocMap
// 	refcfe827.num_payloads_valid, cnum_payloads_valid_allocs = (C.uint)(x.NumPayloadsValid), cgoAllocsUnknown
// 	allocscfe827.Borrow(cnum_payloads_valid_allocs)

// 	var cnum_bytes_received_allocs *cgoAllocMap
// 	refcfe827.num_bytes_received, cnum_bytes_received_allocs = (C.ulong)(x.NumBytesReceived), cgoAllocsUnknown
// 	allocscfe827.Borrow(cnum_bytes_received_allocs)

// 	x.refcfe827 = refcfe827
// 	x.allocscfe827 = allocscfe827
// 	return refcfe827, allocscfe827

// }

// // PassValue does the same as PassRef except that it will try to dereference the returned pointer.
// func (x FrameDataStats) PassValue() (C.framedatastats_s, *cgoAllocMap) {
// 	if x.refcfe827 != nil {
// 		return *x.refcfe827, nil
// 	}
// 	ref, allocs := x.PassRef()
// 	return *ref, allocs
// }

// // Deref uses the underlying reference to C object and fills the wrapping struct with values.
// // Do not forget to call this method whether you get a struct for C object and want to read its values.
// func (x *FrameDataStats) Deref() {
// 	if x.refcfe827 == nil {
// 		return
// 	}
// 	x.NumFramesDetected = (uint32)(x.refcfe827.num_frames_detected)
// 	x.NumHeadersValid = (uint32)(x.refcfe827.num_headers_valid)
// 	x.NumPayloadsValid = (uint32)(x.refcfe827.num_payloads_valid)
// 	x.NumBytesReceived = (uint32)(x.refcfe827.num_bytes_received)
// }

// // allocFlexFrameGenPropsMemory allocates memory for type C.flexframegenprops_s in C.
// // The caller is responsible for freeing the this memory via C.free.
// func allocFlexFrameGenPropsMemory(n int) unsafe.Pointer {
// 	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFlexFrameGenPropsValue))
// 	if mem == nil {
// 		panic(fmt.Sprintln("memory alloc error: ", err))
// 	}
// 	return mem
// }

// const sizeOfFlexFrameGenPropsValue = unsafe.Sizeof([1]C.flexframegenprops_s{})

// // Ref returns the underlying reference to C object or nil if struct is nil.
// func (x *FlexFrameGenProps) Ref() *C.flexframegenprops_s {
// 	if x == nil {
// 		return nil
// 	}
// 	return x.ref4b632eee
// }

// // Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// // Does nothing if struct is nil or has no allocation map.
// func (x *FlexFrameGenProps) Free() {
// 	if x != nil && x.allocs4b632eee != nil {
// 		x.allocs4b632eee.(*cgoAllocMap).Free()
// 		x.ref4b632eee = nil
// 	}
// }

// // NewFlexFrameGenPropsRef creates a new wrapper struct with underlying reference set to the original C object.
// // Returns nil if the provided pointer to C object is nil too.
// func NewFlexFrameGenPropsRef(ref unsafe.Pointer) *FlexFrameGenProps {
// 	if ref == nil {
// 		return nil
// 	}
// 	obj := new(FlexFrameGenProps)
// 	obj.ref4b632eee = (*C.flexframegenprops_s)(unsafe.Pointer(ref))
// 	return obj
// }

// // PassRef returns the underlying C object, otherwise it will allocate one and set its values
// // from this wrapping struct, counting allocations into an allocation map.
// func (x *FlexFrameGenProps) PassRef() (*C.flexframegenprops_s, *cgoAllocMap) {
// 	if x == nil {
// 		return nil, nil
// 	} else if x.ref4b632eee != nil {
// 		return x.ref4b632eee, nil
// 	}
// 	mem4b632eee := allocFlexFrameGenPropsMemory(1)
// 	ref4b632eee := (*C.flexframegenprops_s)(mem4b632eee)
// 	allocs4b632eee := new(cgoAllocMap)
// 	allocs4b632eee.Add(mem4b632eee)

// 	var ccheck_allocs *cgoAllocMap
// 	ref4b632eee.check, ccheck_allocs = (C.uint)(x.Check), cgoAllocsUnknown
// 	allocs4b632eee.Borrow(ccheck_allocs)

// 	var cfec0_allocs *cgoAllocMap
// 	ref4b632eee.fec0, cfec0_allocs = (C.uint)(x.Fec0), cgoAllocsUnknown
// 	allocs4b632eee.Borrow(cfec0_allocs)

// 	var cfec1_allocs *cgoAllocMap
// 	ref4b632eee.fec1, cfec1_allocs = (C.uint)(x.Fec1), cgoAllocsUnknown
// 	allocs4b632eee.Borrow(cfec1_allocs)

// 	var cmod_scheme_allocs *cgoAllocMap
// 	ref4b632eee.mod_scheme, cmod_scheme_allocs = (C.uint)(x.ModScheme), cgoAllocsUnknown
// 	allocs4b632eee.Borrow(cmod_scheme_allocs)

// 	x.ref4b632eee = ref4b632eee
// 	x.allocs4b632eee = allocs4b632eee
// 	return ref4b632eee, allocs4b632eee

// }

// // PassValue does the same as PassRef except that it will try to dereference the returned pointer.
// func (x FlexFrameGenProps) PassValue() (C.flexframegenprops_s, *cgoAllocMap) {
// 	if x.ref4b632eee != nil {
// 		return *x.ref4b632eee, nil
// 	}
// 	ref, allocs := x.PassRef()
// 	return *ref, allocs
// }

// // Deref uses the underlying reference to C object and fills the wrapping struct with values.
// // Do not forget to call this method whether you get a struct for C object and want to read its values.
// func (x *FlexFrameGenProps) Deref() {
// 	if x.ref4b632eee == nil {
// 		return
// 	}
// 	x.Check = (uint32)(x.ref4b632eee.check)
// 	x.Fec0 = (uint32)(x.ref4b632eee.fec0)
// 	x.Fec1 = (uint32)(x.ref4b632eee.fec1)
// 	x.ModScheme = (uint32)(x.ref4b632eee.mod_scheme)
// }

// // unpackArgSFrameSyncStats transforms a sliced Go data structure into plain C format.
// func unpackArgSFrameSyncStats(x []FrameSyncStats) (unpacked *C.framesyncstats_s, allocs *cgoAllocMap) {
// 	if x == nil {
// 		return nil, nil
// 	}
// 	allocs = new(cgoAllocMap)
// 	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
// 		go a.Free()
// 	})

// 	len0 := len(x)
// 	mem0 := allocFrameSyncStatsMemory(len0)
// 	allocs.Add(mem0)
// 	h0 := &sliceHeader{
// 		Data: mem0,
// 		Cap:  len0,
// 		Len:  len0,
// 	}
// 	v0 := *(*[]C.framesyncstats_s)(unsafe.Pointer(h0))
// 	for i0 := range x {
// 		allocs0 := new(cgoAllocMap)
// 		v0[i0], allocs0 = x[i0].PassValue()
// 		allocs.Borrow(allocs0)
// 	}
// 	h := (*sliceHeader)(unsafe.Pointer(&v0))
// 	unpacked = (*C.framesyncstats_s)(h.Data)
// 	return
// }

// // packSFrameSyncStats reads sliced Go data structure out from plain C format.
// func packSFrameSyncStats(v []FrameSyncStats, ptr0 *C.framesyncstats_s) {
// 	const m = 0x7fffffff
// 	for i0 := range v {
// 		ptr1 := (*(*[m / sizeOfFrameSyncStatsValue]C.framesyncstats_s)(unsafe.Pointer(ptr0)))[i0]
// 		v[i0] = *NewFrameSyncStatsRef(unsafe.Pointer(&ptr1))
// 	}
// }

// // unpackArgSFrameDataStats transforms a sliced Go data structure into plain C format.
// func unpackArgSFrameDataStats(x []FrameDataStats) (unpacked *C.framedatastats_s, allocs *cgoAllocMap) {
// 	if x == nil {
// 		return nil, nil
// 	}
// 	allocs = new(cgoAllocMap)
// 	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
// 		go a.Free()
// 	})

// 	len0 := len(x)
// 	mem0 := allocFrameDataStatsMemory(len0)
// 	allocs.Add(mem0)
// 	h0 := &sliceHeader{
// 		Data: mem0,
// 		Cap:  len0,
// 		Len:  len0,
// 	}
// 	v0 := *(*[]C.framedatastats_s)(unsafe.Pointer(h0))
// 	for i0 := range x {
// 		allocs0 := new(cgoAllocMap)
// 		v0[i0], allocs0 = x[i0].PassValue()
// 		allocs.Borrow(allocs0)
// 	}
// 	h := (*sliceHeader)(unsafe.Pointer(&v0))
// 	unpacked = (*C.framedatastats_s)(h.Data)
// 	return
// }

// // packSFrameDataStats reads sliced Go data structure out from plain C format.
// func packSFrameDataStats(v []FrameDataStats, ptr0 *C.framedatastats_s) {
// 	const m = 0x7fffffff
// 	for i0 := range v {
// 		ptr1 := (*(*[m / sizeOfFrameDataStatsValue]C.framedatastats_s)(unsafe.Pointer(ptr0)))[i0]
// 		v[i0] = *NewFrameDataStatsRef(unsafe.Pointer(&ptr1))
// 	}
// }

// // copyPUcharBytes copies the data from Go slice as *C.uchar.
// func copyPUcharBytes(slice *sliceHeader) (*C.uchar, *cgoAllocMap) {
// 	allocs := new(cgoAllocMap)
// 	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
// 		go a.Free()
// 	})

// 	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
// 		Data: slice.Data,
// 		Len:  int(sizeOfUcharValue) * slice.Len,
// 		Cap:  int(sizeOfUcharValue) * slice.Len,
// 	}))))
// 	allocs.Add(mem0)

// 	return (*C.uchar)(mem0), allocs
// }

// // allocUcharMemory allocates memory for type C.uchar in C.
// // The caller is responsible for freeing the this memory via C.free.
// func allocUcharMemory(n int) unsafe.Pointer {
// 	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfUcharValue))
// 	if mem == nil {
// 		panic(fmt.Sprintln("memory alloc error: ", err))
// 	}
// 	return mem
// }

// const sizeOfUcharValue = unsafe.Sizeof([1]C.uchar{})

// // unpackArgSComplexfloat transforms a sliced Go data structure into plain C format.
// func unpackArgSComplexfloat(x []Complexfloat) (unpacked *C.liquid_float_complex, allocs *cgoAllocMap) {
// 	if x == nil {
// 		return nil, nil
// 	}
// 	allocs = new(cgoAllocMap)
// 	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
// 		go a.Free()
// 	})

// 	len0 := len(x)
// 	mem0 := allocLiquidFloatComplexMemory(len0)
// 	allocs.Add(mem0)
// 	h0 := &sliceHeader{
// 		Data: mem0,
// 		Cap:  len0,
// 		Len:  len0,
// 	}
// 	v0 := *(*[]C.liquid_float_complex)(unsafe.Pointer(h0))
// 	for i0 := range x {
// 		allocs0 := new(cgoAllocMap)
// 		v0[i0], allocs0 = x[i0].PassValue()
// 		allocs.Borrow(allocs0)
// 	}
// 	h := (*sliceHeader)(unsafe.Pointer(&v0))
// 	unpacked = (*C.liquid_float_complex)(h.Data)
// 	return
// }

// // unpackPCharString copies the data from Go string as *C.char.
// func unpackPCharString(str string) (*C.char, *cgoAllocMap) {
// 	allocs := new(cgoAllocMap)
// 	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
// 		go a.Free()
// 	})

// 	mem0 := unsafe.Pointer(C.CString(str))
// 	allocs.Add(mem0)
// 	return (*C.char)(mem0), allocs
// }

// type stringHeader struct {
// 	Data unsafe.Pointer
// 	Len  int
// }
