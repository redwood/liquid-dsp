// THE AUTOGENERATED LICENSE. ALL THE RIGHTS ARE RESERVED BY ROBOTS.

// WARNING: This file has automatically been generated on Tue, 16 Nov 2021 17:36:23 CST.
// Code generated by https://git.io/c-for-go. DO NOT EDIT.

package liquiddsp

/*
#cgo CFLAGS: -msse4.1 -Wall -fPIC -I. -I.. -I../include
#cgo LDFLAGS: -L${SRCDIR}/.. -lliquid
#include <inttypes.h>
#include <complex.h>
#include "liquid.h"
#include "liquid.internal.h"
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"runtime"
	"unsafe"
)

// GMSKModCreate function as declared in include/liquid.h:7491
func GMSKModCreate(k uint32, m uint32, bt float32) GMSKMod {
	ck, ckAllocMap := (C.uint)(k), cgoAllocsUnknown
	cm, cmAllocMap := (C.uint)(m), cgoAllocsUnknown
	cbt, cbtAllocMap := (C.float)(bt), cgoAllocsUnknown
	__ret := C.gmskmod_create(ck, cm, cbt)
	runtime.KeepAlive(cbtAllocMap)
	runtime.KeepAlive(cmAllocMap)
	runtime.KeepAlive(ckAllocMap)
	__v := *(*GMSKMod)(unsafe.Pointer(&__ret))
	return __v
}

// GMSKModDestroy function as declared in include/liquid.h:7494
func GMSKModDestroy(q GMSKMod) int32 {
	cq, cqAllocMap := *(*C.gmskmod)(unsafe.Pointer(&q)), cgoAllocsUnknown
	__ret := C.gmskmod_destroy(cq)
	runtime.KeepAlive(cqAllocMap)
	__v := (int32)(__ret)
	return __v
}

// GMSKModPrint function as declared in include/liquid.h:7495
func GMSKModPrint(q GMSKMod) int32 {
	cq, cqAllocMap := *(*C.gmskmod)(unsafe.Pointer(&q)), cgoAllocsUnknown
	__ret := C.gmskmod_print(cq)
	runtime.KeepAlive(cqAllocMap)
	__v := (int32)(__ret)
	return __v
}

// GMSKModReset function as declared in include/liquid.h:7496
func GMSKModReset(q GMSKMod) int32 {
	cq, cqAllocMap := *(*C.gmskmod)(unsafe.Pointer(&q)), cgoAllocsUnknown
	__ret := C.gmskmod_reset(cq)
	runtime.KeepAlive(cqAllocMap)
	__v := (int32)(__ret)
	return __v
}

// GMSKModModulate function as declared in include/liquid.h:7497
func GMSKModModulate(q GMSKMod, sym uint32, y []LiquidFloatComplex) int32 {
	cq, cqAllocMap := *(*C.gmskmod)(unsafe.Pointer(&q)), cgoAllocsUnknown
	csym, csymAllocMap := (C.uint)(sym), cgoAllocsUnknown
	cy, cyAllocMap := unpackArgSLiquidFloatComplex(y)
	__ret := C.gmskmod_modulate(cq, csym, cy)
	packSLiquidFloatComplex(y, cy)
	runtime.KeepAlive(cyAllocMap)
	runtime.KeepAlive(csymAllocMap)
	runtime.KeepAlive(cqAllocMap)
	__v := (int32)(__ret)
	return __v
}

// GMSKDemodCreate function as declared in include/liquid.h:7509
func GMSKDemodCreate(k uint32, m uint32, bt float32) GMSKDemod {
	ck, ckAllocMap := (C.uint)(k), cgoAllocsUnknown
	cm, cmAllocMap := (C.uint)(m), cgoAllocsUnknown
	cbt, cbtAllocMap := (C.float)(bt), cgoAllocsUnknown
	__ret := C.gmskdem_create(ck, cm, cbt)
	runtime.KeepAlive(cbtAllocMap)
	runtime.KeepAlive(cmAllocMap)
	runtime.KeepAlive(ckAllocMap)
	__v := *(*GMSKDemod)(unsafe.Pointer(&__ret))
	return __v
}

// GMSKDemodDestroy function as declared in include/liquid.h:7512
func GMSKDemodDestroy(q GMSKDemod) int32 {
	cq, cqAllocMap := *(*C.gmskdem)(unsafe.Pointer(&q)), cgoAllocsUnknown
	__ret := C.gmskdem_destroy(cq)
	runtime.KeepAlive(cqAllocMap)
	__v := (int32)(__ret)
	return __v
}

// GMSKDemodPrint function as declared in include/liquid.h:7513
func GMSKDemodPrint(q GMSKDemod) int32 {
	cq, cqAllocMap := *(*C.gmskdem)(unsafe.Pointer(&q)), cgoAllocsUnknown
	__ret := C.gmskdem_print(cq)
	runtime.KeepAlive(cqAllocMap)
	__v := (int32)(__ret)
	return __v
}

// GMSKDemodReset function as declared in include/liquid.h:7514
func GMSKDemodReset(q GMSKDemod) int32 {
	cq, cqAllocMap := *(*C.gmskdem)(unsafe.Pointer(&q)), cgoAllocsUnknown
	__ret := C.gmskdem_reset(cq)
	runtime.KeepAlive(cqAllocMap)
	__v := (int32)(__ret)
	return __v
}

// GMSKDemodSetEqBw function as declared in include/liquid.h:7515
func GMSKDemodSetEqBw(q GMSKDemod, bw float32) int32 {
	cq, cqAllocMap := *(*C.gmskdem)(unsafe.Pointer(&q)), cgoAllocsUnknown
	cbw, cbwAllocMap := (C.float)(bw), cgoAllocsUnknown
	__ret := C.gmskdem_set_eq_bw(cq, cbw)
	runtime.KeepAlive(cbwAllocMap)
	runtime.KeepAlive(cqAllocMap)
	__v := (int32)(__ret)
	return __v
}

// GMSKDemodDemodulate function as declared in include/liquid.h:7516
func GMSKDemodDemodulate(q GMSKDemod, y []LiquidFloatComplex, sym []uint32) int32 {
	cq, cqAllocMap := *(*C.gmskdem)(unsafe.Pointer(&q)), cgoAllocsUnknown
	cy, cyAllocMap := unpackArgSLiquidFloatComplex(y)
	csym, csymAllocMap := copyPUintBytes((*sliceHeader)(unsafe.Pointer(&sym)))
	__ret := C.gmskdem_demodulate(cq, cy, csym)
	runtime.KeepAlive(csymAllocMap)
	packSLiquidFloatComplex(y, cy)
	runtime.KeepAlive(cyAllocMap)
	runtime.KeepAlive(cqAllocMap)
	__v := (int32)(__ret)
	return __v
}
